<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>关于Function.prototype.toString的野生小技巧 | 拴萝卜的棍子</title>
  <meta name="author" content="leeluolee">
  
  <meta name="description" content="所有涉及javascript的一切(nodejs, frontend-develop, compile-to-js...etc) 和各种Web相关">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="关于Function.prototype.toString的野生小技巧"/>
  <meta property="og:site_name" content="拴萝卜的棍子"/>

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="拴萝卜的棍子" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <script src="/js/jquery.js"></script>
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-41582683-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">拴萝卜的棍子</a></h1>
  <h2><a href="/">萝卜的技术博客</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/atom.xml">订阅</a></li>
    
      <li><a href="https://github.com/leeluolee">Github</a></li>
    
      <li><a href="/resume">关于我(简历)</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-13T03:46:36.000Z"><a href="/2015/04/13/function-to-string/">4月 13 2015</a></time>
      
      
  
    <h1 class="title">关于Function.prototype.toString的野生小技巧</h1>
  

    </header>
    <div class="entry">
      
        <p><strong>⚠约定</strong>: 以下将<code>Function.prototype.toString</code>简称为<code>fn.toString</code></p>
<p><em>我发现自己快没救了，又把一个短文硬生生写成了长文，客官慢用…</em></p>
<h2 id="先介绍下Function-protoype-toString"><strong>先介绍下Function.protoype.toString</strong></h2>
<blockquote>
<p>The toString() method returns a string representing the source code of the function.<br>—- from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString" target="_blank" rel="external">MDN</a></p>
</blockquote>
<p>即这个原型方法可以帮助你获得 <strong>函数的源代码！！</strong>, 比如</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span> <span class="params">( msg )</span></span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( hello.toString() );</div></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'function hello( msg ){ \</span></div><div class="line">  console.log("hello") \</div><div class="line">}'</div></pre></td></tr></table></figure>

<p>这个方法真是碉堡了…, 通过合适的正则, 我们可以从中提取出丰富的信息.</p>
<ul>
<li>函数名</li>
<li>函数形参列表</li>
<li>函数源代码</li>
</ul>
<p>这些信息提供了javascript意想不到的灵活性, 我们来看看野生的例子吧.</p>
<h2 id="提取AMD模块定义里的依赖列表-">提取AMD模块定义里的依赖列表.</h2>
<p>熟悉AMD或者被CMD科普过的同学应该知道，AMD中是这样定义模块的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模块c的定义</span></div><div class="line">define( [<span class="string">'a'</span>, <span class="string">'b'</span>] ,<span class="function"><span class="keyword">function</span> <span class="params">( a, b )</span> </span>{</div><div class="line"></div><div class="line">  <span class="keyword">return</span> {</div><div class="line">    action: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="keyword">return</span> a.key + b.key;</div><div class="line">    }</div><div class="line">  }</div><div class="line">});</div></pre></td></tr></table></figure>

<p>当此模块加载完成的同时define函数将被运行，传入依赖列表的<code>&#39;b&#39;</code>和<code>&#39;a&#39;</code>指导模块加载器需要先获得他们的模块定义, 并以参数形式注入到<code>c</code>模块的factory函数. 所以明确声明的<code>[&#39;a&#39;, &#39;b&#39;]</code>依赖列表至关重要，它指导模块下一步的策略.</p>
<p>事实上，AMD规范中也定义了一种叫<a href="https://github.com/amdjs/amdjs-api/wiki/AMD#simplified-commonjs-wrapping-" target="_blank" rel="external">simplified commonjs wrapping</a>的写法, 可以以类commonjs的写法来定义一个模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> <span class="params">(require, exports, module)</span> </span>{</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>),</div><div class="line">      b = <span class="built_in">require</span>(<span class="string">'b'</span>);</div><div class="line"></div><div class="line">  exports.action = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> a.key + b.key;</div><div class="line">  };</div><div class="line">});</div></pre></td></tr></table></figure>

<p>依赖变成了【使用注入到模块的<code>require</code>函数引入】(如<code>require(&#39;a&#39;)</code>), 但是这就带来了一个问题, <strong>如何获得此模块的依赖列表?</strong></p>
<p>答案当然是使用<code>function.toString</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> rRequire = <span class="regexp">/\brequire\(["'](\w+)["']\)/g</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDependencies</span><span class="params">( fn )</span></span>{</div><div class="line">  <span class="keyword">var</span> map = {};</div><div class="line">  fn.toString().replace(rRequire, <span class="function"><span class="keyword">function</span><span class="params">(all, dep)</span></span>{</div><div class="line">    map[dep] = <span class="number">1</span>;</div><div class="line">  })</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(map);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">getDependencies(<span class="function"><span class="keyword">function</span><span class="params">(require, exports)</span></span>{</div><div class="line"></div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"a"</span>);</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"b"</span>);</div><div class="line"></div><div class="line">    exports.c = <span class="built_in">require</span>(<span class="string">"a"</span>).key + b.key;</div><div class="line">})</div><div class="line"></div><div class="line"><span class="comment">// =&gt; ["a", "b"]</span></div></pre></td></tr></table></figure>

<p>输出<code>[&quot;a&quot;, &quot;b&quot;]</code>, 我们成功获得依赖列表.</p>
<p>当然，这里的正则是简化版的，实际要处理的情况要复杂的多，比如你至少要过滤掉注释里的信息.</p>
<h2 id="多行字符串">多行字符串</h2>
<p>关注ES6的同学应该知道， 在ES6中新增一个特性叫<a href="https://babeljs.io/docs/learn-es6/#template-strings" target="_blank" rel="external">Template String</a>, 除了支持插值可以获得微弱的模板能力之外，它还有一个能力就是</p>
<blockquote>
<p><strong>支持多行字符串的定义</strong></p>
</blockquote>
<p>这个在你定义多行模板字符串的时候非常有用, 可以避免不直观的字符串拼接操作.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> template = `</div><div class="line">&lt;div&gt;</div><div class="line">   <span class="xml"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>{blog.title}<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span></div><div class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'content'</span>&gt;</span>{blog.content}<span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">`</div></pre></td></tr></table></figure>

<p>这个等同于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = <span class="string">"&lt;div&gt;"</span> +</div><div class="line">   <span class="string">"&lt;h2&gt;{blog.title}&lt;/h2&gt;"</span> +</div><div class="line">   <span class="string">"&lt;div class='content'&gt;{blog.content}&lt;/div&gt;"</span>+</div><div class="line"><span class="string">"&lt;/div&gt;"</span></div></pre></td></tr></table></figure>

<p>是不是清晰方便了很多. <strong>可问题是ES6现在正式来了吗？</strong> 没有…</p>
<p>Duang~ <code>function.toString</code>又闪亮登场, 一解我们青黄不接时的尴尬.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rComment = <span class="regexp">/\/\*([\s\S]*?)\*\//</span>;</div><div class="line"><span class="comment">// multiply string</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ms</span><span class="params">(fn)</span></span>{</div><div class="line">  <span class="keyword">return</span> fn.toString().match(rComment)[<span class="number">1</span>]</div><div class="line">};</div><div class="line"></div><div class="line">ms(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="comment">/*</span></div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h2&gt;{blog.title}&lt;/h2&gt;</div><div class="line">    &lt;div class='content'&gt;{blog.content}&lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">*/})</div></pre></td></tr></table></figure>

<p>将会输出下面这段字符串</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">h2</span>&gt;</span>{blog.title}<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">'content'</span>&gt;</span>{blog.content}<span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div></pre></td></tr></table></figure>

<p>因为在通过<code>fn.toString()</code>的时候， 同时会保留函数中的注释，但是注释是不会被执行的，所以我们可以安全的在注释中写一些非js语句，就比如html.</p>
<p>事实上github上已经有一个<a href="https://github.com/sindresorhus/multiline" target="_blank" rel="external">无聊的库</a>做了这件事，并获得了1200个star…,<br>我记得13年做内部系统时就已经用上了这个trick, 所以现在做什么都得快, 勿以点子小而不为.</p>
<p><em>题外话: 管理模板当然有更好的解决方案，可以参考 <a href="http://regularjs.github.io/guide/zh/template/README.html" target="_blank" rel="external">Regularjs指南:如何优雅的管理你的模板</a></em></p>
<h2 id="基于形参约定的依赖注入">基于形参约定的依赖注入</h2>
<p>Angular里有个很大的噱头就是它的依赖注入。</p>
<p>假设现在有如下一段Angularjs的代码，它定义了2个factory:<code>greeter</code>和<code>runner</code>, 以及controller<code>MyController</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>, [])</div><div class="line">.factory(<span class="string">'greeter'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">return</span> {</div><div class="line">    greet: <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> </span>{ alert(msg); }</div><div class="line">  }</div><div class="line">})</div><div class="line">.factory(<span class="string">'runner'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">return</span> {</div><div class="line">    run: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{  }</div><div class="line">  }</div><div class="line">})</div><div class="line">.controller(<span class="string">'MyController'</span>, <span class="function"><span class="keyword">function</span><span class="params">($scope, greeter)</span> </span>{</div><div class="line">  $scope.sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    greeter.greet(<span class="string">"Hello!"</span>);</div><div class="line">  };</div><div class="line">});</div></pre></td></tr></table></figure>

<p>注意这个controller会在angular内部compile遇到节点上的某个指令比如<code>&lt;div ng-controller=&quot;MyController&quot;&gt;</code>时被调用.</p>
<p>现在问题来了, <strong>angular如何知道要传入什么参数呢</strong>？ 比如上例中的controller其实是需要两个参数的.</p>
<p><strong>答案是基于形参名的推测</strong></p>
<p>你可以先简单理解为在每次调用factory等函数时, 对应的定义会缓存起来，例如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cache = {</div><div class="line">  greeter: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line"></div><div class="line">  },</div><div class="line">  runner: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line"></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>既然如此，现在要做的就是获得依赖, <code>function.toString</code>可以帮助我们从形参中获得这些信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> rArgs = <span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParamNames</span><span class="params">( fn )</span></span>{</div><div class="line">  <span class="keyword">var</span> argStr = fn.toString().match(rArgs)[<span class="number">1</span>].trim();</div><div class="line">  <span class="keyword">return</span> argStr? argStr.split(<span class="regexp">/\s*,\s*/</span>): [];</div><div class="line">}</div><div class="line"></div><div class="line">getParamNames(<span class="function"><span class="keyword">function</span><span class="params">( $scope, greeter )</span></span>{})</div><div class="line"></div><div class="line"><span class="comment">// ["$scope", "greeter"]</span></div></pre></td></tr></table></figure>

<p>输出<code>[&quot;$scope&quot;, &quot;greeter&quot;]</code>, 也就意味着我们获得了依赖列表， 这样我们就可以从cache中获得对应的定义了.</p>
<p><strong>即便如此，作者仍然觉得angular式的依赖注入其实完全是一种设计过度, 无论是基于推断还是显示声明</strong></p>
<h2 id="继承中的super()实现-">继承中的<code>super()</code>实现.</h2>
<p>10个前端9个看了js高程那本红书吧，我们先来看下教科书版本的js继承的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 基类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mesh</span><span class="params">()</span></span>{}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SkinnedMesh</span><span class="params">( geometry, materials )</span></span>{</div><div class="line">  Mesh.call( <span class="keyword">this</span>, geometry, materials )</div><div class="line">  <span class="comment">// blablabla...</span></div><div class="line">}</div><div class="line"><span class="comment">// 避免new Mesh，带来的两次构造函数调用</span></div><div class="line">SkinnedMesh.prototye = <span class="built_in">Object</span>.create(Mesh.prototype)</div><div class="line">SkinnedMesh.prototye.constructor = Mesh;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// other</span></div><div class="line"></div><div class="line">SkinnedMesh.prototype.update = <span class="function"><span class="keyword">function</span><span class="params">(camera)</span></span>{</div><div class="line">  Mesh.prototype.update.call(<span class="keyword">this</span>, camera);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种继承方式足够用，但是有几个问题.</p>
<ul>
<li>调用父类函数真的足够繁琐</li>
<li>一旦父类发生改变，所有对父类的调用都要改写</li>
<li>从编程逻辑上看， 这种类式继承不够直观</li>
</ul>
<p>如果是下面这种方式呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SkinnedMesh = Mesh.extend({</div><div class="line">  <span class="comment">// 履行构造函数职责</span></div><div class="line">  init: <span class="function"><span class="keyword">function</span><span class="params">( geometry, materials )</span></span>{</div><div class="line">    <span class="comment">// 由于super是关键字，修改为supr</span></div><div class="line">    <span class="keyword">this</span>.supr( geometry, materials ); <span class="comment">// 调用父类同名方法</span></div><div class="line">  },</div><div class="line">  update: <span class="function"><span class="keyword">function</span><span class="params">( camera )</span></span>{</div><div class="line">    <span class="keyword">this</span>.supr() <span class="comment">// 调用Mesh.prototype.update</span></div><div class="line">  }</div><div class="line">})</div></pre></td></tr></table></figure>

<p><em>上面这段写法其实就是来自于著名的<a href="https://github.com/ded/klass" target="_blank" rel="external">ded/klass</a></em></p>
<p>是不是直观了很多， 事实上上面这段代码修改为使用coffeescript等语法噪音弱的语言来书写，已经非常接近与有关键字支持的语言了.<br>但相信不少人还是会疑惑, 为什么在<code>init</code>和<code>update</code>中调用<code>this.supr()</code>为什么可以准确定位到父类不同的方法？</p>
<p>其实，在extend的同时就已经在查找规则封装好了, 让我们将这个问题简化为两个对象间的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(child, parent)</span></span>{</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> child ) <span class="keyword">if</span> (child.hasOwnProperty(i) ){</div><div class="line">      wrap(i, child, parent)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> child;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> rSupr = <span class="regexp">/\bsupr\b/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span><span class="params">(name, child, parent)</span></span>{</div><div class="line">  <span class="keyword">var</span> method = child[name],</div><div class="line">    superMethod = parent[name];</div><div class="line"></div><div class="line">  <span class="comment">// 我们通过fn.toString() 打印出方法体，并确保它使用的this.supr()</span></div><div class="line">  <span class="keyword">if</span>( rSupr.test( method.toString() ) && superMethod) {</div><div class="line">    superMethod = superMethod.bind(child);</div><div class="line">    child[name] = <span class="function"><span class="keyword">function</span><span class="params">(arguments)</span></span>{</div><div class="line">        <span class="comment">// 保证嵌套函数调用时候正确</span></div><div class="line">        <span class="keyword">var</span> preSuper = child.supr;</div><div class="line">        child.supr = superMethod;</div><div class="line">        method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">        child.supr = preSuper</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> mesh = {</div><div class="line"></div><div class="line">  init: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"mesh init "</span>);</div><div class="line">  },</div><div class="line">  update: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">" mesh update"</span>);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> skinnedmesh = extend({</div><div class="line"></div><div class="line">  init: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.supr()</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"skinnedmesh init "</span>);</div><div class="line">  },</div><div class="line">  update: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.supr()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">" skinnedmesh update"</span>);</div><div class="line">  }</div><div class="line">}, mesh)</div><div class="line"></div><div class="line">skinnedmesh.init();</div><div class="line">skinnedmesh.update();</div></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mesh init</div><div class="line">skinnedmesh init</div><div class="line">mesh update</div><div class="line">skinnedmesh update</div></pre></td></tr></table></figure>

<p>其中, fn.toString()输出方法源码， 并通过正则判断是否源码中调用了supr(). 如果是就包一层函数用来动态的制定this.supr对应的方法。</p>
<p>是不是挺奇妙的构想？事实上由于方法的包裹是发生在extend时，在方法运行时，是没有查找开销的，所以很多框架都使用这个技巧来实现一个简化的继承模型. 包括<a href="https://github.com/regularjs/regular" target="_blank" rel="external">Regularjs</a></p>
<p><strong>题外话:</strong> 再往前看一点，在ES6规范中，已经引入了语言级别的<code>class</code>支持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> SkinnedMesh extends Mesh {</div><div class="line">  constructor(geometry, materials) {</div><div class="line">    super(geometry, materials);</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">  }</div><div class="line">  update( camera ) {</div><div class="line">    <span class="comment">//...</span></div><div class="line">    super.update( camera );</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意构造函数里的super和update里的<code>super()</code>以及<code>super.update()</code>分别用来调用父类的构造函数和实例方法, 相当于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mesh.call(<span class="keyword">this</span>, geometry, materials)</div><div class="line"></div><div class="line">Mesh.prototype.update.call(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>

<p>但还是那个问题: <strong>ES6目前可用了吗?</strong></p>
<h2 id="序列化函数">序列化函数</h2>
<p>什么是函数序列化，即将函数序列话成字符串这种通用数据格式 这样可以实现<strong>程序逻辑在不同的runtime之间传递</strong></p>
<p>我们这里点一个应用场景: 不依赖外部js文件时仍能使用webworker帮助我们进行并行计算</p>
<h3 id="什么是webworker">什么是webworker</h3>
<p>在浏览器中， js的执行与UI更新是公用一个进程, 这导致它们会互相阻塞, 用户直接的感受就是, 在长时间的脚本执行中，界面会“卡住”.</p>
<p>特别在很多处理大列表的场景中，熟练的程序员会通过(setTimeout/setInterval/requestAnimationFrame)等方法来模拟任务分片，<strong>好为UI线程腾出时间</strong>, 这样用户的体验就是按钮可以点了，但总的完成时间其实是增加了</p>
<p>有没有一种一劳永逸的方法呢？ <strong>webworker</strong></p>
<blockquote>
<p>Web Workers provide a simple means for web content to run scripts in background threads.<br>—- <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">MDN: webworker</a></p>
</blockquote>
<p>即我们可以将耗时的计算任务放置在后台运行， 完成之后通过事件来通知主线程, <strong>注意它会真正生成系统级别的线程，而不是模拟出来的</strong>。</p>
<p><em>事实上，worker分为专用worker和共享worker，我们只会涉及到前者</em></p>
<p>我们来个耗时的例子，第一个映入我脑帘的就是计算斐波那契数列, 足够简单但是足够耗时, 就它了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"num"</span> <span class="attribute">placeholder</span>=<span class="value">"请输入你要计算的数值"</span> <span class="attribute">value</span>=<span class="value">40</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"compute()"</span>&gt;</span>使用worker计算<span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"compute(1)"</span>&gt;</span>不使用worker<span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">hr</span>/&gt;</span></div><div class="line">结果: <span class="tag">&lt;<span class="title">output</span> <span class="attribute">id</span>=<span class="value">"result"</span>&gt;</span><span class="tag">&lt;/<span class="title">output</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">button</span>&gt;</span>点我看看UI线程阻塞了吗<span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'mytask.js'</span>);</div><div class="line">  <span class="keyword">var</span> vnode = <span class="built_in">document</span>.getElementById(<span class="string">"num"</span>);</div><div class="line">  <span class="keyword">var</span> rnode = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">compute</span><span class="params">(noWorker)</span> </span>{</div><div class="line">    <span class="keyword">var</span> value = <span class="built_in">parseInt</span>(vnode.value || <span class="number">0</span>, <span class="number">10</span>) ;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(noWorker){</div><div class="line">      <span class="built_in">console</span>.time(<span class="string">"fibonacci-noworker"</span>)</div><div class="line">      rnode.textContent = fibonacci( value );</div><div class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.timeEnd(<span class="string">"fibonacci-noworker"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.time(<span class="string">"fibonacci-worker"</span>)</div><div class="line">    worker.postMessage( value );</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  worker.onmessage= <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    rnode.textContent = e.data;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"fibonacci-worker"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span> </span>{</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</div><div class="line">    <span class="keyword">return</span> fibonacci( n - <span class="number">1</span> ) + fibonacci(n - <span class="number">2</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>对应的mytask.js,如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">onmessage = <span class="function"><span class="keyword">function</span><span class="params">( ev )</span></span>{</div><div class="line">  self.postMessage( fibonacci( ev.data ) );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span> </span>{</div><div class="line">  <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</div><div class="line">  <span class="keyword">return</span> fibonacci( n - <span class="number">1</span> ) + fibonacci(n - <span class="number">2</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>mytask.js与worker.html的文件结构如下.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">└── <span class="built_in">folder</span></div><div class="line">  ├── mytask.js</div><div class="line">  └── worker.html</div></pre></td></tr></table></figure>

<p>打开worker.html, 分别点击两个按钮, 你会发现控制台输出结果是这样的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fibonacci-worker: <span class="number">1299.735</span>ms</div><div class="line">fibonacci-noworker: <span class="number">5198.129</span>ms</div></pre></td></tr></table></figure>

<p>使用worker的版本速度会更高一些， 当然更关键的问题是 <strong>noworker版本阻塞的UI线程，使得button等控件都没有反应了</strong>.</p>
<h3 id="使用function-toString实现单文件的Webworker运算">使用function.toString实现单文件的Webworker运算</h3>
<p>但是, <strong>非worker版本有个好处就是逻辑定义都在一个文件里</strong>， 而不用分散计算逻辑到子文件， 有没有两全的方案呢？</p>
<p>答案是 <strong>使用<code>function.toString()</code> 和 <code>URL.createObjectURL</code> 方法来动态创建脚本文件内容</strong>.</p>
<p>我们对worker.html做以下调整</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"num"</span> <span class="attribute">placeholder</span>=<span class="value">"请输入你要计算的数值"</span> <span class="attribute">value</span>=<span class="value">40</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"compute()"</span>&gt;</span>使用内联式的worker计算<span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">hr</span>/&gt;</span></div><div class="line">结果: <span class="tag">&lt;<span class="title">output</span> <span class="attribute">id</span>=<span class="value">"result"</span>&gt;</span><span class="tag">&lt;/<span class="title">output</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">button</span>&gt;</span>点我看看UI线程阻塞了吗<span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">workerify</span><span class="params">(fn)</span> </span>{</div><div class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(</div><div class="line">        URL.createObjectURL(<span class="keyword">new</span> Blob([</div><div class="line">           <span class="string">'self.onmessage = '</span> + fn.toString()], {</div><div class="line">           type: <span class="string">'application/javascript'</span></div><div class="line">        })</div><div class="line">    ));</div><div class="line">    <span class="keyword">return</span> worker</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">compute</span><span class="params">(noWorker)</span> </span>{</div><div class="line">    <span class="keyword">var</span> value = <span class="built_in">parseInt</span>(vnode.value || <span class="number">0</span>, <span class="number">10</span>) ;</div><div class="line">    worker.postMessage( value );</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">var</span> worker = workerify(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span> </span>{</div><div class="line">      <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</div><div class="line">      <span class="keyword">return</span> fibonacci( n - <span class="number">1</span> ) + fibonacci(n - <span class="number">2</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> self.postMessage( fibonacci(e.data) )</div><div class="line">  })</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">var</span> vnode = <span class="built_in">document</span>.getElementById(<span class="string">"num"</span>);</div><div class="line">  <span class="keyword">var</span> rnode = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</div><div class="line"></div><div class="line">  worker.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{</div><div class="line">    rnode.textContent = e.data;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>这一次，我们不再需要mytask.js了，因为这个文件内容其实已经通过 <code>URL.createObjectURL</code> 和 <code>Blob</code>创建出来了. 关于这两个API的详细描述，大家请自行MDN，再延伸下去，此文就没法控制了。</p>
<h2 id="总结">总结</h2>
<p>其实<code>fn.toString()</code>所有的能力都归结为它可以得到函数源码，配合new Function(), 事实上还可以产生更大的可能性. 比如我们可以将服务器端的逻辑传递到客户端，<br>而不仅仅只是传递数据.</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript/">javascript</a>
  </div>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>


</div></div>
    <aside id="sidebar" class="alignright">
<div class="search">
  <form action="http://google.com/search" method="get" accept-charset="utf-8">
    <input type="text" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:leeluolee.github.com">
  </form>
</div>


<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/tutorial/">tutorial</a><small>1</small></li>
  
  </ul>
</div>



<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/npm/">npm</a><small>1</small></li>
  
    <li><a href="/tags/tool/">tool</a><small>3</small></li>
  
    <li><a href="/tags/javascript/">javascript</a><small>6</small></li>
  
    <li><a href="/tags/regularjs/">regularjs</a><small>3</small></li>
  
    <li><a href="/tags/mcss/">mcss</a><small>2</small></li>
  
    <li><a href="/tags/css/">css</a><small>2</small></li>
  
    <li><a href="/tags/3d/">3d</a><small>1</small></li>
  
    <li><a href="/tags/requirejs/">requirejs</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
  </ul>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 leeluolee
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'leeluolee';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

  <script async src="//codepen.io/assets/embed/ei.js"></script>

</body>
</html>